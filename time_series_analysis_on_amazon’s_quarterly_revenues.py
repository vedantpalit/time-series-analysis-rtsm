# -*- coding: utf-8 -*-
"""Time Series Analysis on Amazonâ€™s Quarterly Revenues.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k_ILQ7pQ3XzglCfSWhuSlko-tq13Ugc5

#Dataset Preprocessing and Imports
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import mean_squared_error
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf,plot_pacf
pd.options.mode.chained_assignment = None  # default='warn'

from google.colab import drive
drive.mount('/content/drive')

df=pd.read_excel('/content/drive/MyDrive/RTSM DATASET/MM25.xlsx')

df.head()

df.isnull().sum()

df.drop(['Net Income (US $M)'],axis=1,inplace=True)
df.rename(columns = {'Revenue (US $M)':'Value'}, inplace = True)

def convert_to_int(value):
    return int(value.replace('$', '').replace(',', ''))

# Apply the function to the 'profit' column
df['Value'] = df['Value'].apply(convert_to_int)

df.set_index('Quarter',inplace=True)
df

"""# Dataset Decomposition"""

plt.figure(dpi=200,figsize=(8,6))
plt.plot(df.index,df['Value'],marker='o', linestyle='-', color='b', label='Rev vs Quarter')
plt.xlabel('Quarters')
plt.ylabel('Revenues')
plt.title("Amazon's Quarterly Revenues")
plt.legend()
plt.grid(True)
plt.savefig('figure2.pdf')
plt.show()

plt.rcParams["figure.dpi"] = 200
plt.rcParams["figure.figsize"] = [8, 6]

df_copy=df[::-1]

from statsmodels.tsa.seasonal import seasonal_decompose
decompose_data = seasonal_decompose(df_copy, model="additive")
decompose_data.plot()
plt.savefig('figure3.pdf')

"""- Here we can see that the range of trend and residual is nominal, or we can say that trend is having variation between 0 to 80000, and most of the time residual is having the variation around 0. But for the seasonality, we can see that it varies between -2000 to 5000

## Seasonality plot
"""

seasonality=decompose_data.seasonal
seasonality.plot(color='green')
plt.savefig('figure4.pdf')

from statsmodels.tsa.stattools import adfuller
dftest = adfuller(df.Value, autolag = 'AIC')
print("1. ADF : ",dftest[0])
print("2. P-Value : ", dftest[1])
print("3. Num Of Lags : ", dftest[2])
print("4. Num Of Observations Used For ADF Regression and Critical Values Calculation :", dftest[3])
print("5. Critical Values :")
for key, val in dftest[4].items():
    print("\t",key, ": ", val)


if dftest[1] <= 0.05:
        print("strong evidence against the null hypothesis, reject the null hypothesis. Data has no unit root and is stationary")
else:
        print("weak evidence against null hypothesis, time series has a unit root, indicating it is non-stationary \n")

"""- Here we can see that the p-value is higher for our dataset, and we can say that the evidence of the null hypothesis is low; hence the time series is non-stationary.

#ARIMA Testing
"""

#auto regressive model

def AR(p,df):
  df_temp = df

  #Generating the lagged p terms
  for i in range(1,p+1):
    df_temp['Shifted_values_%d' % i ] = df_temp['Value'].shift(i)

  train_size = (int)(0.8 * df_temp.shape[0])

  #Breaking data set into test and training
  df_train = pd.DataFrame(df_temp[0:train_size])
  df_test = pd.DataFrame(df_temp[train_size:df.shape[0]])

  df_train_2 = df_train.dropna()
  #X contains the lagged values ,hence we skip the first column
  X_train = df_train_2.iloc[:,1:].values.reshape(-1,p)
  #Y contains the value,it is the first column
  y_train = df_train_2.iloc[:,0].values.reshape(-1,1)

  #Running linear regression to generate the coefficents of lagged terms
  from sklearn.linear_model import LinearRegression
  lr = LinearRegression()
  lr.fit(X_train,y_train)

  theta  = lr.coef_.T
  intercept = lr.intercept_
  df_train_2['Predicted_Values'] = X_train.dot(lr.coef_.T) + lr.intercept_
  # df_train_2[['Value','Predicted_Values']].plot()

  X_test = df_test.iloc[:,1:].values.reshape(-1,p)
  df_test['Predicted_Values'] = X_test.dot(lr.coef_.T) + lr.intercept_
  # df_test[['Value','Predicted_Values']].plot()

  RMSE = np.sqrt(mean_squared_error(df_test['Value'], df_test['Predicted_Values']))

  print("The RMSE is :", RMSE,", Value of p : ",p)
  return [df_train_2,df_test,theta,intercept,RMSE]

#moving average

def MA(q,res):

  for i in range(1,q+1):
    res['Shifted_values_%d' % i ] = res['Residuals'].shift(i)

  train_size = (int)(0.8 * res.shape[0])

  res_train = pd.DataFrame(res[0:train_size])
  res_test = pd.DataFrame(res[train_size:res.shape[0]])

  res_train_2 = res_train.dropna()
  X_train = res_train_2.iloc[:,1:].values.reshape(-1,q)
  y_train = res_train_2.iloc[:,0].values.reshape(-1,1)

  from sklearn.linear_model import LinearRegression
  lr = LinearRegression()
  lr.fit(X_train,y_train)

  theta  = lr.coef_.T
  intercept = lr.intercept_
  res_train_2['Predicted_Values'] = X_train.dot(lr.coef_.T) + lr.intercept_
  # res_train_2[['Residuals','Predicted_Values']].plot()

  X_test = res_test.iloc[:,1:].values.reshape(-1,q)
  res_test['Predicted_Values'] = X_test.dot(lr.coef_.T) + lr.intercept_
  res_test[['Residuals','Predicted_Values']].plot()

  from sklearn.metrics import mean_squared_error
  RMSE = np.sqrt(mean_squared_error(res_test['Residuals'], res_test['Predicted_Values']))

  print("The RMSE is :", RMSE,", Value of q : ",q)
  return [res_train_2,res_test,theta,intercept,RMSE]

def adf_check(time_series):
    """
    Pass in a time series, returns ADF report
    """
    result = adfuller(time_series)
    print('Augmented Dickey-Fuller Test:')
    labels = ['ADF Test Statistic','p-value','Number of Lags Used','Number of Observations Used']

    for value,label in zip(result,labels):
        print(label+' : '+str(value) )

    if result[1] <= 0.05:
        print("strong evidence against the null hypothesis, reject the null hypothesis. Data has no unit root and is stationary")
    else:
        print("weak evidence against null hypothesis, time series has a unit root, indicating it is non-stationary \n")

"""We make the dataset stationary for the implementation of ARIMA and run adf test again"""

df_testing = pd.DataFrame(np.log(df.Value).diff().diff(2))
adf_check(df_testing.Value.dropna())

# print(df_testing.to_string())
df_testing.plot(marker='o', linestyle='-', color='b', label='Stationarized Rev vs Quarter')
plt.xlabel('Quarters')
plt.ylabel('Stationarized Revenues')
plt.title("Amazon's Quarterly Revenue Stationarized")
plt.legend()
plt.grid(True)
plt.savefig('figure5.pdf')
plt.show()

CF = plot_acf(df_testing.dropna(),lags=12)
plt.savefig('figure6.pdf')

PACF = plot_pacf(df_testing.dropna(),lags=12)
plt.savefig('figure7.pdf')

r=[]
p=[]
for i in range(1,13):
  [df_train,df_test,theta,intercept,RMSE] = AR(i,pd.DataFrame(df_testing.Value))
  r.append(RMSE)
  p.append(i)
plt.figure(dpi=200)
plt.plot(p, r, marker='o', linestyle='-', color='black', label='RMSE vs p')
plt.xlabel('p')
plt.ylabel('RMSE')
plt.title('RMSE vs p')
plt.legend()
plt.grid(True)
plt.savefig('figure8.pdf')
plt.show()

min_rmse = min(r)
min_rmse_index = r.index(min_rmse)

# Corresponding p-value at the minimum RMSE
optimal_p_value = p[min_rmse_index]

print("Minimum RMSE:", min_rmse)
print("Corresponding p-value:", optimal_p_value)

[df_train,df_test,theta,intercept,RMSE] = AR(optimal_p_value,pd.DataFrame(df_testing.Value))

df_c = pd.concat([df_train,df_test])
df_c[['Value','Predicted_Values']].plot(linestyle='-')
plt.xlabel('Quarters')
plt.ylabel('Stationarized Revenues')
plt.title("AutoRegressive Predictions")
plt.legend()
plt.grid(True)
plt.savefig('figure9.pdf')
plt.show()

df_c['Residuals'] = df_c.Value - df_c.Predicted_Values

df_c.plot(x='Predicted_Values', y='Residuals', style='o',color='red')
plt.xlabel('Predicted_Values')
plt.ylabel('Residuals')
plt.title("Residual vs Fitted Values")
plt.legend()
plt.grid(True)
plt.savefig('figure10.pdf')
plt.show()

res = pd.DataFrame()
res['Residuals'] = df_c.Value - df_c.Predicted_Values
res

fig, ax = plt.subplots(figsize=(8, 6))
stats.probplot(res['Residuals'], dist="norm", plot=ax)
ax.get_lines()[1].set_linestyle('--')  # Add dashed line for perfect normal distribution
ax.set_title('Q-Q Plot for Autoregressive Method')
ax.set_xlabel('Theoretical Quantiles')
ax.set_ylabel('Sample Quantiles')
plt.grid(True)
plt.savefig('figure11.pdf')
plt.show()

res.plot(kind='kde')
plt.xlabel('Residuals')
plt.ylabel('Density')
plt.title("Density Dist of Residual(AR)")
plt.legend()
plt.grid(True)
plt.savefig('figure12.pdf')
plt.show()

r=[]
q=[]
for i in range(1,14):
  [res_train,res_test,theta,intercept,RMSE] = MA(i,pd.DataFrame(res.Residuals))
  r.append(RMSE)
  q.append(i)
plt.figure(dpi=200)
plt.plot(q, r, marker='o', linestyle='-', color='black', label='RMSE vs q')
plt.xlabel('q')
plt.ylabel('RMSE')
plt.title('RMSE vs q')
plt.legend()
plt.grid(True)
plt.savefig('figure13.pdf')
plt.show()

min_rmse = min(r)
min_rmse_index = r.index(min_rmse)

# Corresponding p-value at the minimum RMSE
optimal_q_value = q[min_rmse_index]

print("Minimum RMSE:", min_rmse)
print("Corresponding q-value:", optimal_q_value)

[res_train,res_test,theta,intercept,RMSE] = MA(optimal_q_value,pd.DataFrame(res.Residuals))
plt.xlabel('Quarters')
plt.ylabel('Stationarized Revenues')
plt.title("Moving Average Predictions")
plt.legend()
plt.grid(True)
plt.savefig('figure14.pdf')
plt.show()
print(theta)
print(intercept)

res_c = pd.concat([res_train,res_test])
res_c

df_c.Predicted_Values += res_c.Predicted_Values

df_c[['Value','Predicted_Values']].plot()
plt.xlabel('Quarters')
plt.ylabel('Stationarized Revenues')
plt.title("Moving Average Predictions")
plt.legend()
plt.grid(True)
plt.savefig('figure15.pdf')
plt.show()

df_c.Value += np.log(df).shift(1).Value
df_c.Value += np.log(df).diff().shift(2).Value
df_c.Predicted_Values += np.log(df).shift(1).Value
df_c.Predicted_Values += np.log(df).diff().shift(2).Value
df_c.Value = np.exp(df_c.Value)
df_c.Predicted_Values = np.exp(df_c.Predicted_Values)

df_c

df_c.iloc[:,:][['Value','Predicted_Values']].plot(marker='o', linestyle='-',label='Rev vs Quarter')
plt.xlabel('Quarters')
plt.ylabel('Revenues')
plt.title("ARIMA Predictions vs Original Values")
plt.legend()
plt.grid(True)
plt.savefig('figure16.pdf')
plt.show()

Mean_RMSE_ARIMA=((df_c.Value - df_c.Predicted_Values) ** 2).mean() ** .5

print("The Mean Root-Mean-Square Error in ARIMA:",Mean_RMSE_ARIMA)

"""#Moving Average Testing"""

df_new_1 = pd.read_excel("/content/drive/MyDrive/RTSM DATASET/MM25.xlsx")

df_new_1.drop(['Net Income (US $M)'],axis=1,inplace=True)
df_new_1.rename(columns = {'Revenue (US $M)':'Value'}, inplace = True)

def convert_to_int(value):
    return int(value.replace('$', '').replace(',', ''))

# Apply the function to the 'profit' column
df_new_1['Value'] = df_new_1['Value'].apply(convert_to_int)

df_new_1.set_index('Quarter',inplace=True)

df_new_1

import pandas as pd


data = df_new_1


df = pd.DataFrame(data)


df = df.rename(columns={"Value": "Revenue"})
df

q=[]
r=[]
for i in range(3,12):
  predicted_values = df_new_1['Value'].rolling(window=i).mean()
  rmse_score_i=((df_new_1.Value - predicted_values) ** 2).mean() ** .5
  r.append(rmse_score_i)
  q.append(i)
  print("The RMSE is :", rmse_score_i,", Value of window size : ",i)
plt.figure(dpi=200)
plt.plot(q, r, marker='o', linestyle='-', color='black', label='RMSE vs window_size')
plt.xlabel('window size')
plt.ylabel('RMSE')
plt.title('RMSE vs window size')
plt.legend()
plt.grid(True)
plt.savefig("figure17.pdf")
plt.show()

min_rmse = min(r)
min_rmse_index = r.index(min_rmse)

# Corresponding p-value at the minimum RMSE
optimal_q_value = q[min_rmse_index]

print("Minimum RMSE:", min_rmse)
print("Corresponding window_size-value:", optimal_q_value)

q=[]
r=[]
for i in range(6,12):
  predicted_values = df_new_1['Value'].rolling(window=i).mean()
  rmse_score_i=((df_new_1.Value - predicted_values) ** 2).mean() ** .5
  r.append(rmse_score_i)
  q.append(i)
  print("The RMSE is :", rmse_score_i,", Value of window size : ",i)
plt.figure(dpi=200)
plt.plot(q, r, marker='o', linestyle='-', color='red', label='RMSE vs window_size')
plt.xlabel('window size')
plt.ylabel('RMSE')
plt.title('RMSE vs window size')
plt.legend()
plt.grid(True)
plt.savefig("figure18.pdf")
plt.show()

min_rmse = min(r)
min_rmse_index = r.index(min_rmse)

# Corresponding p-value at the minimum RMSE
optimal_q_value_1 = q[min_rmse_index]

print("Minimum RMSE:", min_rmse)
print("Corresponding window_size-value:", optimal_q_value_1)

import matplotlib.pyplot as plt
df_new_1['MA_3'] = df_new_1['Value'].rolling(window=optimal_q_value).mean()
df_new_1['MA_6'] = df_new_1['Value'].rolling(window=optimal_q_value_1).mean()


# Calculate residuals for both moving averages
df_new_1['Residuals_MA_3'] = df_new_1['Value'] - df_new_1['MA_3']
df_new_1['Residuals_MA_6'] = df_new_1['Value'] - df_new_1['MA_6']

# Plotting the actual, predicted, and residuals


# Actual Revenue
plt.plot(df_new_1.index, df_new_1['Value'], label='Actual Revenue', color='blue')

# Predicted Revenue (Moving Averages)
plt.plot(df_new_1.index, df_new_1['MA_3'], label='3-Month MA', color='orange')
plt.plot(df_new_1.index, df_new_1['MA_6'], label='6-Month MA', color='green')

# Residuals for the 3-month moving average
plt.scatter(df_new_1.index, df_new_1['Residuals_MA_6'], label='3-Month Residuals', color='red', s=10)

# Residuals for the 6-month moving average
plt.scatter(df_new_1.index, df_new_1['Residuals_MA_6'], label='6-Month Residuals', color='purple', s=10)

plt.title('Moving Averages Predictions vs Original Values')
plt.xlabel('Quarter')
plt.ylabel('Revenue')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()  # Adjust the plot to ensure everything fits without overlapping

plt.savefig('figure19.pdf')
# Show the plot
plt.show()

from scipy import stats

fig, ax = plt.subplots(figsize=(8, 6))
stats.probplot(df_new_1['Residuals_MA_3'], dist="norm", plot=ax)
ax.get_lines()[1].set_linestyle('--')  # Add dashed line for perfect normal distribution
ax.set_title('Q-Q Plot for MA(w=3) Method')
ax.set_xlabel('Theoretical Quantiles')
ax.set_ylabel('Sample Quantiles')
plt.grid(True)
plt.savefig('figure21.pdf')
plt.show()

df_new_1['Residuals_MA_3'].plot(kind='kde')
plt.xlabel('Residuals')
plt.ylabel('Density')
plt.title("Density Dist of Residual(MA w=3)")
plt.legend()
plt.grid(True)
plt.savefig('figure20.pdf')
plt.show()

fig, ax = plt.subplots(figsize=(8, 6))
stats.probplot(df_new_1['Residuals_MA_6'], dist="norm", plot=ax)
ax.get_lines()[1].set_linestyle('--')  # Add dashed line for perfect normal distribution
ax.set_title('Q-Q Plot for MA(w=6) Method')
ax.set_xlabel('Theoretical Quantiles')
ax.set_ylabel('Sample Quantiles')
plt.grid(True)
plt.savefig('figure23.pdf')
plt.show()

df_new_1['Residuals_MA_6'].plot(kind='kde')
plt.xlabel('Residuals')
plt.ylabel('Density')
plt.title("Density Dist of Residual(MA w=6)")
plt.legend()
plt.grid(True)
plt.savefig('figure22.pdf')
plt.show()

"""#EWMA Testing"""

q=[]
r=[]
for i in range(3,8):
  predicted_values = df_new_1['Value'].ewm(span=i, adjust=True).mean()
  rmse_score_i=((df_new_1.Value - predicted_values) ** 2).mean() ** .5
  r.append(rmse_score_i)
  q.append(i)
  print("The RMSE is :", rmse_score_i,", Value of window size : ",i)
plt.figure(dpi=200)
plt.plot(q, r, marker='o', linestyle='-', color='purple', label='RMSE vs window_size')
plt.xlabel('window size')
plt.ylabel('RMSE')
plt.title('RMSE vs window size')
plt.legend()
plt.grid(True)
plt.savefig('figure24.pdf')
plt.show()

min_rmse = min(r)
min_rmse_index = r.index(min_rmse)

# Corresponding p-value at the minimum RMSE
optimal_q_value = q[min_rmse_index]

print("Minimum RMSE:", min_rmse)
print("Corresponding window_size-value:", optimal_q_value)

q=[]
r=[]
for i in range(6,12):
  predicted_values = df_new_1['Value'].ewm(span=i, adjust=True).mean()
  rmse_score_i=((df_new_1.Value - predicted_values) ** 2).mean() ** .5
  r.append(rmse_score_i)
  q.append(i)
  print("The RMSE is :", rmse_score_i,", Value of window size : ",i)
plt.figure(dpi=200)
plt.plot(q, r, marker='o', linestyle='-', color='orange', label='RMSE vs window_size')
plt.xlabel('window size')
plt.ylabel('RMSE')
plt.title('RMSE vs window size')
plt.legend()
plt.grid(True)
plt.savefig("figure25.pdf")
plt.show()

min_rmse = min(r)
min_rmse_index = r.index(min_rmse)

# Corresponding p-value at the minimum RMSE
optimal_q_value_1 = q[min_rmse_index]

print("Minimum RMSE:", min_rmse)
print("Corresponding window_size-value:", optimal_q_value_1)

alp_array=np.arange(0.1,1,0.05)

q=[]
r=[]
for i in alp_array:
  predicted_values = df_new_1['Value'].ewm(adjust=True,alpha=i).mean()
  rmse_score_i=((df_new_1.Value - predicted_values) ** 2).mean() ** .5
  r.append(rmse_score_i)
  q.append(i)
  print("The RMSE is :", rmse_score_i,", Value of alpha : ",i)
plt.figure(dpi=200)
plt.plot(q, r, marker='o', linestyle='-', color='black', label='RMSE vs alpha')
plt.xlabel('alpha')
plt.ylabel('RMSE')
plt.title('RMSE vs alpha(smoothing constant) ')
plt.legend()
plt.grid(True)
plt.savefig("figure26.pdf")
plt.show()

min_rmse = min(r)
min_rmse_index = r.index(min_rmse)

# Corresponding p-value at the minimum RMSE
optimal_q_value_2 = q[min_rmse_index]

print("Minimum RMSE:", min_rmse)
print("Corresponding alpha-value:", optimal_q_value_2)

# Exponentially Weighted Moving Average (EWMA) for different spans

# Here we'll choose two different spans (short and long-term trends)
span_short = optimal_q_value  # Short-term trend
span_long = optimal_q_value_1   # Long-term trend
best_alpha=optimal_q_value_2 #best-alpha

df_new_1['EWMA_3'] = df_new_1['Value'].ewm(span=span_short, adjust=True).mean()
df_new_1['EWMA_6'] = df_new_1['Value'].ewm(span=span_long, adjust=True).mean()
df_new_1['EWMA_best_alpha'] = df_new_1['Value'].ewm(adjust=True,alpha=best_alpha).mean()
# Calculate residuals for both EWMA
df_new_1['Residuals_EWMA_3'] = df_new_1['Value'] - df_new_1['EWMA_3']
df_new_1['Residuals_EWMA_6'] = df_new_1['Value'] - df_new_1['EWMA_6']
df_new_1['Residuals_EWMA_best_alpha'] = df_new_1['Value'] - df_new_1['EWMA_best_alpha']

# Actual Revenue
plt.plot(df_new_1.index, df_new_1['Value'], label='Actual Revenue', color='blue')

# Predicted Revenue (EWMA)
plt.plot(df_new_1.index, df_new_1['EWMA_3'], label='EWMA Short Term', color='orange')
plt.plot(df_new_1.index, df_new_1['EWMA_6'], label='EWMA Long Term', color='green')
plt.plot(df_new_1.index, df_new_1['EWMA_best_alpha'], label='EWMA best-alpha=0.95', color='red')
# Residuals for the EWMA short term
plt.scatter(df_new_1.index, df_new_1['Residuals_EWMA_3'], label='EWMA Short Term Residuals', color='red', s=10)

# Residuals for the EWMA long term
plt.scatter(df_new_1.index, df_new_1['Residuals_EWMA_6'], label='EWMA Long Term Residuals', color='purple', s=10)

#Residuals for the EWMA best alpha
plt.scatter(df_new_1.index, df_new_1['Residuals_EWMA_best_alpha'], label='EWMA best-alpha Residuals', color='purple', s=10)

plt.title('EWMA Predictions vs Original Values')
plt.xlabel('Quarter')
plt.ylabel('Revenue')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()  # Adjust the plot to ensure everything fits without overlapping

plt.savefig("figure27.pdf")
# Show the plot
plt.show()

RMSE_EWMA_short=((df_new_1.Value - df_new_1.EWMA_3) ** 2).mean() ** .5
RMSE_EWMA_long=((df_new_1.Value - df_new_1.EWMA_6) ** 2).mean() ** .5
RMSE_EWMA_bestalpha=((df_new_1.Value - df_new_1.EWMA_best_alpha) ** 2).mean() ** .5

print("The Mean Root-Mean-Square Error in EWMA for short span(3):",RMSE_EWMA_short)
print()
print("The Mean Root-Mean-Square Error in EWMA for long span(6):",RMSE_EWMA_long)
print()
print("The Mean Root-Mean-Square Error in EWMA for best-alpha(0.95):",RMSE_EWMA_bestalpha)

fig, ax = plt.subplots(figsize=(8, 6))
stats.probplot(df_new_1['Residuals_EWMA_3'], dist="norm", plot=ax)
ax.get_lines()[1].set_linestyle('--')  # Add dashed line for perfect normal distribution
ax.set_title('Q-Q Plot for EWMA(w=3) method')
ax.set_xlabel('Theoretical Quantiles')
ax.set_ylabel('Sample Quantiles')
plt.grid(True)
plt.savefig("figure28.pdf")
plt.show()

df_new_1['Residuals_EWMA_3'].plot(kind='kde')
plt.xlabel('Residuals')
plt.ylabel('Density')
plt.title("Density Dist of Residual(EWMA w=3)")
plt.legend()
plt.grid(True)
plt.savefig('figure29.pdf')
plt.show()

fig, ax = plt.subplots(figsize=(8, 6))
stats.probplot(df_new_1['Residuals_EWMA_6'], dist="norm", plot=ax)
ax.get_lines()[1].set_linestyle('--')  # Add dashed line for perfect normal distribution
ax.set_title('Q-Q Plot for EWMA(w=6) method')
ax.set_xlabel('Theoretical Quantiles')
ax.set_ylabel('Sample Quantiles')
plt.grid(True)
plt.savefig('figure30.pdf')
plt.show()

df_new_1['Residuals_EWMA_6'].plot(kind='kde')
plt.xlabel('Residuals')
plt.ylabel('Density')
plt.title("Density Dist of Residual(EWMA w=6)")
plt.legend()
plt.grid(True)
plt.savefig('figure31.pdf')
plt.show()

fig, ax = plt.subplots(figsize=(8, 6))
stats.probplot(df_new_1['Residuals_EWMA_best_alpha'], dist="norm", plot=ax)
ax.get_lines()[1].set_linestyle('--')  # Add dashed line for perfect normal distribution
ax.set_title('Q-Q Plot for EWMA($alpha$=0.95) method')
ax.set_xlabel('Theoretical Quantiles')
ax.set_ylabel('Sample Quantiles')
plt.grid(True)
plt.savefig("figure32.pdf")
plt.show()

df_new_1['Residuals_EWMA_best_alpha'].plot(kind='kde')
plt.xlabel('Residuals')
plt.ylabel('Density')
plt.title("Density Dist of Residual(EWMA $alpha$=0.95)")
plt.legend()
plt.grid(True)
plt.savefig('figure33.pdf')
plt.show()

"""#Holt's Method Testing"""

from statsmodels.tsa.holtwinters import ExponentialSmoothing

# Build the model
holt_model = ExponentialSmoothing(df_new_1['Value'], trend='add').fit()

# Make predictions
df_new_1['Holt'] = holt_model.fittedvalues

# Calculate residuals for Holt's method
df_new_1['Residuals_Holt'] = df_new_1['Value'] - df_new_1['Holt']

# Plotting the actual, predicted (Holt), and residuals


# Actual Revenue
plt.plot(df_new_1.index, df_new_1['Value'], label='Actual Revenue', color='blue')

# Predicted Revenue (Holt)
plt.plot(df_new_1.index, df_new_1['Holt'], label='Holt\'s Prediction', color='orange')

# Residuals for Holt's method
plt.scatter(df_new_1.index, df_new_1['Residuals_Holt'], label='Holt\'s Residuals', color='red', s=10)

plt.title('Holt Predictions vs Original Values')
plt.xlabel('Quarter')
plt.ylabel('Revenue')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()  # Adjust the plot to ensure everything fits without overlapping

plt.savefig("figure34.pdf")
# Show the plot
plt.show()

RMSE_Holt=((df_new_1.Value - df_new_1.Holt) ** 2).mean() ** .5

print("The Mean Root-Mean-Square Error in Holt Method:",RMSE_Holt)

fig, ax = plt.subplots(figsize=(8, 6))
stats.probplot(df_new_1['Residuals_Holt'], dist="norm", plot=ax)
ax.get_lines()[1].set_linestyle('--')  # Add dashed line for perfect normal distribution
ax.set_title('Q-Q Plot for Holt\'s method')
ax.set_xlabel('Theoretical Quantiles')
ax.set_ylabel('Sample Quantiles')
plt.grid(True)
plt.savefig("figure35.pdf")
plt.show()

df_new_1['Residuals_Holt'].plot(kind='kde')
plt.xlabel('Residuals')
plt.ylabel('Density')
plt.title("Density Dist of Residual(Holt)")
plt.legend()
plt.grid(True)
plt.savefig('figure36.pdf')
plt.show()

"""#Holt-Winters Method Testing"""

seasonal_periods = 4

# Build the model
holt_winters_model = ExponentialSmoothing(
    df_new_1['Value'],
    trend='add',
    seasonal='add',
    seasonal_periods=seasonal_periods
).fit()

# Make predictions
df_new_1['Holt_Winters'] = holt_winters_model.fittedvalues

# Calculate residuals for Holt-Winters method
df_new_1['Residuals_Holt_Winters'] = df_new_1['Value'] - df_new_1['Holt_Winters']

# Plotting the actual, predicted (Holt-Winters), and residuals

# Actual Revenue
plt.plot(df_new_1.index, df_new_1['Value'], label='Actual Revenue', color='blue')

# Predicted Revenue (Holt-Winters)
plt.plot(df_new_1.index, df_new_1['Holt_Winters'], label='Holt-Winters Prediction', color='green')

# Residuals for Holt-Winters method
plt.scatter(df_new_1.index, df_new_1['Residuals_Holt_Winters'], label='Holt-Winters Residuals', color='purple', s=10)

plt.title('Holt-Winters Predictions vs Original Values')
plt.xlabel('Quarter')
plt.ylabel('Revenue')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()  # Adjust the plot to ensure everything fits without overlapping

plt.savefig("figure37.pdf")
# Show the plot
plt.show()

RMSE_Holt_winter=((df_new_1.Value - df_new_1.Holt_Winters) ** 2).mean() ** .5

print("The Mean Root-Mean-Square Error in Holt-Winter's Method:",RMSE_Holt_winter)

fig, ax = plt.subplots(figsize=(8, 6))
stats.probplot(df_new_1['Residuals_Holt_Winters'], dist="norm", plot=ax)
ax.get_lines()[1].set_linestyle('--')  # Add dashed line for perfect normal distribution
ax.set_title('Q-Q Plot for Holt-Winters method ')
ax.set_xlabel('Theoretical Quantiles')
ax.set_ylabel('Sample Quantiles')
plt.grid(True)
plt.savefig("figure38.pdf")
plt.show()

df_new_1['Residuals_Holt_Winters'].plot(kind='kde')
plt.xlabel('Residuals')
plt.ylabel('Density')
plt.title("Density Dist of Residual(Holt-Winters)")
plt.legend()
plt.grid(True)
plt.savefig('figure39.pdf')
plt.show()

"""#SARIMA Testing"""

r=[]
p=[]
for i in range(1,13):
  [df_train,df_test,theta,intercept,RMSE] = AR(i,pd.DataFrame(df_new_1.Value))
  r.append(RMSE)
  p.append(i)
plt.figure(dpi=200)
plt.plot(p, r, marker='o', linestyle='-', color='black', label='RMSE vs p')
plt.xlabel('p')
plt.ylabel('RMSE')
plt.title('RMSE vs p')
plt.legend()
plt.grid(True)
plt.savefig("figure40.pdf")
plt.show()

min_rmse = min(r)
min_rmse_index = r.index(min_rmse)

# Corresponding p-value at the minimum RMSE
optimal_p_value = p[min_rmse_index]

print("Minimum RMSE:", min_rmse)
print("Corresponding p-value:", optimal_p_value)

df_new = pd.concat([df_train,df_test])
df_new[['Value','Predicted_Values']].plot()

res = pd.DataFrame()
res['Residuals'] = df_new.Value - df_new.Predicted_Values
res

r=[]
q=[]
for i in range(1,14):
  [res_train,res_test,theta,intercept,RMSE] = MA(i,pd.DataFrame(res.Residuals))
  r.append(RMSE)
  q.append(i)
plt.figure(dpi=200)
plt.plot(q, r, marker='o', linestyle='-', color='black', label='RMSE vs q')
plt.xlabel('q')
plt.ylabel('RMSE')
plt.title('RMSE vs q')
plt.legend()
plt.grid(True)
plt.savefig('figure44.pdf')
plt.show()

min_rmse = min(r)
min_rmse_index = r.index(min_rmse)

# Corresponding q-value at the minimum RMSE
optimal_q_value_fin = q[min_rmse_index]

print("Minimum RMSE:", min_rmse)
print("Corresponding q-value:", optimal_q_value_fin)

from statsmodels.tsa.statespace.sarimax import SARIMAX

# Define the model parameters
p, d, q = optimal_p_value, 0,optimal_q_value_fin   # AR(5) model
P, D, Q, s = 0, 0, 0, 4  # 4 seasonal components

# Build the SARIMAX model
sarimax_model = SARIMAX(df_new_1['Value'], order=(p, d, q), seasonal_order=(P, D, Q, s), enforce_stationarity=False, enforce_invertibility=False).fit()

# Make predictions
df_new_1['SARIMAX'] = sarimax_model.fittedvalues

# Calculate residuals for SARIMAX
df_new_1['Residuals_SARIMAX'] = df_new_1['Value'] - df_new_1['SARIMAX']

# Plotting the actual, predicted (SARIMAX), and residuals


# Actual Revenue
plt.plot(df_new_1.index, df_new_1['Value'], label='Actual Revenue', color='blue')

# Predicted Revenue (SARIMAX)
plt.plot(df_new_1.index, df_new_1['SARIMAX'], label='SARIMAX Prediction', color='orange')

# Residuals for SARIMAX
plt.scatter(df_new_1.index, df_new_1['Residuals_SARIMAX'], label='SARIMAX Residuals', color='red', s=10)

plt.title('SARIMAX Predictions vs Original Values')
plt.xlabel('Quarter')
plt.ylabel('Revenue')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()  # Adjust the plot to ensure everything fits without overlapping

plt.savefig("figure41.pdf")
# Show the plot
plt.show()

fig, ax = plt.subplots(figsize=(8, 6))
stats.probplot(df_new_1['Residuals_SARIMAX'], dist="norm", plot=ax)
ax.get_lines()[1].set_linestyle('--')  # Add dashed line for perfect normal distribution
ax.set_title('Q-Q Plot for SARIMAX Method')
ax.set_xlabel('Theoretical Quantiles')
ax.set_ylabel('Sample Quantiles')
plt.grid(True)
plt.savefig("figure42.pdf")
plt.show()

df_new_1['Residuals_SARIMAX'].plot(kind='kde')
plt.xlabel('Residuals')
plt.ylabel('Density')
plt.title("Density Dist of Residual(SARIMA)")
plt.legend()
plt.grid(True)
plt.savefig('figure43.pdf')
plt.show()

RMSE_SARIMAX=((df_new_1.Value - df_new_1.SARIMAX) ** 2).mean() ** .5

print("The Mean Root-Mean-Square Error in SARIMAX Method:",RMSE_SARIMAX)